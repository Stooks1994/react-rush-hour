{"ast":null,"code":"var _jsxFileName = \"/Users/ian/react/rush-hour/src/components/Piece.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState } from 'react';\nimport Draggable from 'react-draggable';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst BOARD_SIZE = 6;\nconst SIZE_MOD = 100 / BOARD_SIZE;\nconst AXIS = {\n  x: 'x',\n  y: 'y'\n};\n\nconst calculateBounds = (id, x, y, h, w, allPieces, axis) => {\n  let boardBoundingRect = document.getElementById('main-board').getBoundingClientRect();\n  let tileSize = boardBoundingRect.width / BOARD_SIZE;\n  let left = parseInt(0 - x * tileSize);\n  let top = parseInt(0 - y * tileSize);\n  let right = parseInt(boardBoundingRect.width - (w + x) * tileSize);\n  let bottom = parseInt(boardBoundingRect.height - (h + y) * tileSize);\n  allPieces.forEach(otherPiece => {\n    if (id != otherPiece.id) {\n      if (axis == AXIS.x) {\n        if (x >= otherPiece.x && y >= otherPiece.y && y < otherPiece.y + otherPiece.h) {\n          left = parseInt(0 - (x - (otherPiece.x + otherPiece.w)) * tileSize);\n        } else if (x < otherPiece.x && y >= otherPiece.y && y <= otherPiece.y + otherPiece.h) {\n          right = parseInt(boardBoundingRect.width - (w + x + otherPiece.w) * tileSize);\n        }\n      } else if (axis == AXIS.y) {\n        if (y >= otherPiece.y && x >= otherPiece.x && x < otherPiece.x + otherPiece.w) {\n          top = parseInt(0 - (y - (otherPiece.y + otherPiece.h)) * tileSize);\n        } else if (y < otherPiece.y && x >= otherPiece.x && x < otherPiece.x + otherPiece.w) {\n          bottom = parseInt(boardBoundingRect.height - (h + y + otherPiece.h) * tileSize);\n        }\n      }\n    }\n  });\n  console.log(left + \" \" + top + \" \" + right + \" \" + bottom + \" \");\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom\n  };\n};\n\nconst preparePiece = (id, x, y, h, w, allPieces, axis, color, coordHandler, isMounted) => {\n  let xPos = x * SIZE_MOD;\n  let yPos = y * SIZE_MOD;\n  let height = h * SIZE_MOD;\n  let width = w * SIZE_MOD;\n  let bounds = calculateBounds(id, x, y, h, w, allPieces, axis);\n  return /*#__PURE__*/_jsxDEV(Draggable, {\n    axis: axis,\n    bounds: bounds,\n    onStop: coordHandler,\n    position: {\n      x: 0,\n      y: 0\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      id: id,\n      style: {\n        position: 'absolute',\n        left: `${xPos}%`,\n        top: `${yPos}%`,\n        height: `${height}%`,\n        width: `${width}%`,\n        backgroundColor: `${color}`\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 59,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 58,\n    columnNumber: 9\n  }, this);\n};\n\nconst Piece = props => {\n  _s();\n\n  const [currX, setCurrX] = useState(props.pieceProps.x);\n  const [currY, setCurrY] = useState(props.pieceProps.y);\n  const [isMounted, setIsMounted] = useState(false);\n\n  const passNewBinToParent = () => {\n    let currElement = document.getElementById(props.pieceProps.id);\n    let boardPx = document.getElementById('main-board').getBoundingClientRect().width;\n    let vals = currElement.style.transform.match(/-?[0-9]+/gm);\n    let tileSize = boardPx / BOARD_SIZE;\n\n    if (vals.length == 1) {\n      // Only has transform in X direction\n      let xTransform = Number(vals[0]);\n      let newOffset = currElement.offsetLeft + xTransform;\n      let newBin = 0;\n\n      if (newOffset <= 0.5 * tileSize) {\n        newBin = 0;\n      } else if (newOffset <= 1.5 * tileSize && newOffset > 0.5 * tileSize) {\n        newBin = 1;\n      } else if (newOffset <= 2.5 * tileSize && newOffset > 1.5 * tileSize) {\n        newBin = 2;\n      } else if (newOffset <= 3.5 * tileSize && newOffset > 2.5 * tileSize) {\n        newBin = 3;\n      } else if (newOffset <= 4.5 * tileSize && newOffset > 3.5 * tileSize) {\n        newBin = 4;\n      } else {\n        newBin = 5;\n      }\n\n      props.onFinishedDragging(props.pieceProps.id, newBin);\n    } else {\n      // Has transforms for both X and Y directions -- X will be 0\n      let yTransform = Number(vals[1]);\n      let newOffset = currElement.offsetTop + yTransform;\n      let newBin = 0;\n\n      if (newOffset <= 0.5 * tileSize) {\n        newBin = 0;\n      } else if (newOffset <= 1.5 * tileSize && newOffset > 0.5 * tileSize) {\n        newBin = 1;\n      } else if (newOffset <= 2.5 * tileSize && newOffset > 1.5 * tileSize) {\n        newBin = 2;\n      } else if (newOffset <= 3.5 * tileSize && newOffset > 2.5 * tileSize) {\n        newBin = 3;\n      } else if (newOffset <= 4.5 * tileSize && newOffset > 3.5 * tileSize) {\n        newBin = 4;\n      } else {\n        newBin = 5;\n      }\n\n      props.onFinishedDragging(props.pieceProps.id, newBin);\n    }\n  };\n\n  let currPiece = props.pieceProps.orientation == 'HORIZONTAL' ? preparePiece(props.pieceProps.id, props.pieceProps.x, props.pieceProps.y, props.pieceProps.h, props.pieceProps.w, props.allPieces, 'x', props.pieceProps.color, passNewBinToParent, isMounted) : preparePiece(props.pieceProps.id, props.pieceProps.x, props.pieceProps.y, props.pieceProps.h, props.pieceProps.w, props.allPieces, 'y', props.pieceProps.color, passNewBinToParent, isMounted);\n  return currPiece;\n};\n\n_s(Piece, \"8hxzkWxjzip/MIArT+k4qGkRP7U=\");\n\n_c = Piece;\nexport default Piece;\n\nvar _c;\n\n$RefreshReg$(_c, \"Piece\");","map":{"version":3,"sources":["/Users/ian/react/rush-hour/src/components/Piece.js"],"names":["React","useEffect","useState","Draggable","BOARD_SIZE","SIZE_MOD","AXIS","x","y","calculateBounds","id","h","w","allPieces","axis","boardBoundingRect","document","getElementById","getBoundingClientRect","tileSize","width","left","parseInt","top","right","bottom","height","forEach","otherPiece","console","log","preparePiece","color","coordHandler","isMounted","xPos","yPos","bounds","position","backgroundColor","Piece","props","currX","setCurrX","pieceProps","currY","setCurrY","setIsMounted","passNewBinToParent","currElement","boardPx","vals","style","transform","match","length","xTransform","Number","newOffset","offsetLeft","newBin","onFinishedDragging","yTransform","offsetTop","currPiece","orientation"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react'\nimport Draggable from 'react-draggable';\n\nconst BOARD_SIZE = 6;\nconst SIZE_MOD = 100 / BOARD_SIZE;\n\nconst AXIS = {\n    x: 'x',\n    y: 'y'\n}\n\nconst calculateBounds = (id, x, y, h, w, allPieces, axis) => {\n    let boardBoundingRect = document.getElementById('main-board').getBoundingClientRect();\n    let tileSize = boardBoundingRect.width / BOARD_SIZE;\n\n    let left = parseInt(0 - (x * tileSize));\n    let top = parseInt(0 - (y * tileSize));\n    let right = parseInt(boardBoundingRect.width - ((w + x) * tileSize));\n    let bottom = parseInt(boardBoundingRect.height - ((h + y) * tileSize));\n    \n    allPieces.forEach(otherPiece => {\n        if (id != otherPiece.id) {\n            if (axis == AXIS.x) {\n                if (x >= otherPiece.x && y >= otherPiece.y && y < otherPiece.y + otherPiece.h) {\n                    left = parseInt(0 - ((x - (otherPiece.x + otherPiece.w)) * tileSize))\n                } else if (x < otherPiece.x && y >= otherPiece.y && y <= otherPiece.y + otherPiece.h) {\n                    right = parseInt(boardBoundingRect.width - ((w + x + otherPiece.w) * tileSize))\n                }\n            } else if (axis == AXIS.y) {\n                if (y >= otherPiece.y && x >= otherPiece.x && x < otherPiece.x + otherPiece.w) {\n                    top = parseInt(0 - ((y - (otherPiece.y + otherPiece.h)) * tileSize))\n                } else if (y < otherPiece.y && x >= otherPiece.x && x < otherPiece.x + otherPiece.w) {\n                    bottom = parseInt(boardBoundingRect.height - ((h + y + otherPiece.h) * tileSize))\n                }\n            }\n        }\n    })\n\n    console.log(left + \" \" + top + \" \" + right + \" \" + bottom + \" \" )\n\n    return {\n        left: left, \n        top: top, \n        right: right, \n        bottom: bottom\n    }\n}\n\nconst preparePiece = (id, x, y, h, w, allPieces, axis, color, coordHandler, isMounted) => {\n    let xPos = x * SIZE_MOD;\n    let yPos = y * SIZE_MOD;\n    let height = h * SIZE_MOD;\n    let width = w * SIZE_MOD;\n\n    let bounds = calculateBounds(id, x, y, h, w, allPieces, axis)\n\n    return (\n        <Draggable axis={axis} bounds={bounds} onStop={coordHandler} position={{x:0, y:0}}>\n            <div id={id} style={{\n                position:'absolute', \n                left:`${xPos}%`, \n                top:`${yPos}%`, \n                height:`${height}%`, \n                width:`${width}%`, \n                backgroundColor:`${color}`,\n            }} />\n        </Draggable>\n    )\n}\n\nconst Piece = props => {\n    const [currX, setCurrX] = useState(props.pieceProps.x);\n    const [currY, setCurrY] = useState(props.pieceProps.y);\n    const [isMounted, setIsMounted] = useState(false);\n\n    const passNewBinToParent = () => {\n        let currElement = document.getElementById(props.pieceProps.id)\n\n        let boardPx = document.getElementById('main-board').getBoundingClientRect().width\n        let vals = currElement.style.transform.match(/-?[0-9]+/gm)\n        let tileSize = boardPx / BOARD_SIZE;\n\n        if (vals.length == 1) {\n            // Only has transform in X direction\n            let xTransform = Number(vals[0])\n            let newOffset = currElement.offsetLeft + xTransform\n            let newBin = 0\n\n            if (newOffset <= 0.5 * tileSize) {\n                newBin = 0;\n            } else if (newOffset <= 1.5 * tileSize && newOffset > 0.5 * tileSize) {\n                newBin = 1;\n            } else if (newOffset <= 2.5 * tileSize && newOffset > 1.5 * tileSize) {\n                newBin = 2;\n            } else if (newOffset <= 3.5 * tileSize && newOffset > 2.5 * tileSize) {\n                newBin = 3;\n            } else if (newOffset <= 4.5 * tileSize && newOffset > 3.5 * tileSize) {\n                newBin = 4;\n            } else {\n                newBin = 5;\n            }\n\n            props.onFinishedDragging(props.pieceProps.id, newBin)\n        } else {\n            // Has transforms for both X and Y directions -- X will be 0\n            let yTransform = Number(vals[1])\n            let newOffset = currElement.offsetTop + yTransform\n            let newBin = 0\n\n            if (newOffset <= 0.5 * tileSize) {\n                newBin = 0;\n            } else if (newOffset <= 1.5 * tileSize && newOffset > 0.5 * tileSize) {\n                newBin = 1;\n            } else if (newOffset <= 2.5 * tileSize && newOffset > 1.5 * tileSize) {\n                newBin = 2;\n            } else if (newOffset <= 3.5 * tileSize && newOffset > 2.5 * tileSize) {\n                newBin = 3;\n            } else if (newOffset <= 4.5 * tileSize && newOffset > 3.5 * tileSize) {\n                newBin = 4;\n            } else {\n                newBin = 5;\n            }\n            \n            props.onFinishedDragging(props.pieceProps.id, newBin)\n        }\n    }\n\n    let currPiece = props.pieceProps.orientation == 'HORIZONTAL' \n        ? preparePiece(props.pieceProps.id, props.pieceProps.x, props.pieceProps.y, props.pieceProps.h, props.pieceProps.w, props.allPieces, 'x', props.pieceProps.color, passNewBinToParent, isMounted)\n        : preparePiece(props.pieceProps.id, props.pieceProps.x, props.pieceProps.y, props.pieceProps.h, props.pieceProps.w, props.allPieces, 'y', props.pieceProps.color, passNewBinToParent, isMounted);\n\n    return currPiece;\n}\n\nexport default Piece;"]},"metadata":{},"sourceType":"module"}